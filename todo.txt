o (DrugName, { (GeneName, PhenotypeName) }) -> Recommendation ; what's the limit on set size?
  - if it varies:
    - try cubric:
      X efficient subset join condition?
      - efficient where clause with subseteq: table.s subseteq i where input set i is LARGE (genome size large)?
        - cub_server runs in constant memory for "select count(*)" on table = 22*powerset of {1..20}, i = {1..100000}; 
          however, query is still slow (246.36s) and doesn't seem to be implementing any smart algorithm
          q_time             i={1...x} q_time/x  |table|  
          72.35              10000               23068673  
          246.36s            100000    405.91    23068673  
          605.41s            150000    247.76    23068673  
          1074.37s           200000    186.15    23068673 
        - can we index a set field? If so, does our query run faster?
          - NO, we can't index a set field:
            >> csql> alter table s1 add index s_idx(s);
               
               In the command from line 1,
               
               ERROR: Cannot define index on domain "set".
          - can we generate a unique index key (hash value) for our sets that can be used to reduce the number of candidate 
            sets s such that table.s subseteq i 
            - sounds similar (in particular "candidates") to subset-similarity join literature; so _probably_no_ (not 
              without access to database internals)
        - can we interface cubrid with grails...? If not...maybe django, but probably quit at this point...
          - troubles encountered when building https://github.com/CUBRID/hibernate-core from source and trying to replace 
            hibernate dependencies with custom built jars:
            missing class org.codehaus.groovy.grails.orm.hibernate.support.ClosureEventTriggeringInterceptor

        select count(*) from s1 where s1.s = {1,2,3};
        before index:
        rep q_time
        1   60.00s
        2   61.00
        3
        after index:
        rep q_time
        1
        2
        3

        'select count(*) from s1 where s1.s subseteq '"`perl -e 'print "{", (join ", ", (1..10000)), "}"'`"';'
        before index:
        rep q_time
        1
        2
        3
        after index:
        rep q_time
        1
        2
        3
        
        - create 2 simple tables of subsets of number 1...n, and see how fast 
          it joins
  - if it's within a handful:
    - stick with mysql and create a mapping from gene-names to subsets containing those genes
      - perform a set containment query in memory on candidates
o (GeneName, HaplotypeName, HaplotypeName) -> PhenotypeName ; any reliable source of this information?

- figure out how to obtain (GeneName, HaplotypeName, HaplotypeName) -> (GeneName, PhenotypeName) datasets from results 
  published in CPIC
  - how many haplotypes H are their typically for a given gene (since we need to store |H|^2 rows for a 
    given mapping)?
    - not too many
    - too many; figure out a new mapping ... -> (GeneName, PhenotypeName) that isn't so 
      space/time/management costly, but can still be used to query an input set (GeneName, HaplotypeName, HaplotypeName)
- test current code
  - get some test data
    - andrea's excel file
      - not very consistent in syntax (requires some tinkering to parse everything sanely), but somewhat consistent in data structure
      - cross references things on a by-drug basis
      - data present:
        drug_recommendation (only recommendation)
        gene_phenotype_drug_recommendation
        genotype_phenotype (for 1, pretty inconsistent formatting)
        genotype_drug_recommendation
      - data missing:
        haplotype_snps
        gene_haplotype_variant

    - PharmGKB
      - variation in syntax, but there is an underlying data structure; probably need to write slight variations on parsers for each drug page
      - cross references things on a by-drug basis
      - data present:
        drug_recommendation (only recommendation for some)
        gene_phenotype_drug_recommendation (for some)
        genotype_phenotype (for some; for single gene-drug pairs it's easy to extract [use ajax form on drug page], varies for multi-gene-drug pairs)
        genotype_drug_recommendation (for some)
        haplotype_snps (easy and consistent)
        gene_haplotype_variant (easy and consistent)
      - data missing:
  - use groovy unit test to setup the DB and run the different stages
    - test using different return types:
      - query/existing/engine
- TODO: make sure tables (intermediate result and schema tables) have indexes on "set columns", since joins will be happening on these columns
- make a function for running the whole pipeline from stage 1 (ideally, have some way to hook into the pipeline at various steps, and follow through to a final result)
- refactor Haplotype functions to insert intermediate results into a persistent tables instead of temporary input_* tables, with results identified by pipeline_job_id's
- start unit testing Haplotype functions
  - assert each job table in the pipeline
  - generate some comprehensive test data (use madeup stuff first that is understandable)
  - then use real data

- TODO: fix issue where with selectWhereSetContains where a table with duplicate variants doesn't get output correctly (select distinct on variants, then rejoin mappingings with variants)
    - check what the input list of variants looks like (is it a multiset or just a set?)
      - looks like (snp_id, allele, sample_id) is unique.  In reality though, a patient's genome should have 2 chromosomes, so a given snp can occur 
        at most twice (though not on the same chromosome).  However, we need the input to clarify what snps occur on the same chromosome (otherwise we'd 
        map to haplotypes that are in reality split across 2 chromosomes)
        - TODO: ask lars about this
        - TODO: pending me being right, add a chromosome column to job_variant, and use it as a orderBy in the call to groupedRowsToColumns (in addition 
          to haplotype_name)
        - TODO: the granularity of a job will be a set of patients; figure out how to handle this in the pipeline


Questions:
